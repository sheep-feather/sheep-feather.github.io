{"pages":[{"title":"","text":"# About 源于爱好 QQ:1483261634 微信:w1399969170","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"title: “tags”type: tags","link":"/tags/index.html"}],"posts":[{"title":"Pattern类","text":"# Pattern 模式类，正则表达式的编译表示形式。（好像就是机器识别，计算机识别） # compile 方法 public static Pattern compile(String regex, int flags) { return new Pattern(regex, flags); } public static Pattern compile(String regex) { return new Pattern(regex, 0); } 这两个方法可以获得 pattern 类的实例（创建对象），但传入参数不同。","link":"/2020/07/25/pattern%E7%B1%BB/"},{"title":"增强型for循环","text":"增强型for循环书写格式int[] numArray = { 1, 2, 3, 4, 5, 6 }; for (int i : numArray) { System.out.print(i); }//结果会是123456 原理遍历数组时使用的普通for循环，而遍历集合时使用的Iterator迭代器 注意事项 在使用增强型for循环不支持遍历时删除元素 使用增强型for循环时，对遍历的集合需要做null判断，不然可能引发空指针异常","link":"/2020/07/25/%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF/"},{"title":"浏览器参数和标签使用","text":"# 1. 请求参数的作用： 比如用户通过浏览器访问服务端计算机动态资源文件 student.class 浏览器发送请求时需要携带调用方法需要的实参（请求参数） http://www.baidu.com?n1=100&amp;n2=200 [n1=100&amp;n2=200] 就是浏览器发送的请求参数。 # 2. 请求参数格式 浏览器发送请求时 请求地址？请求参数名 1 = 值 1 &amp; 请求参数名 2 = 值 2 # 3. 浏览器发送请求时携带的请求参数来源 （1）超链接 标签命令 （2）表单域标签命令指定请求参数 （后面有介绍） # 4. 通过超链接标签命令指定请求参数 &lt;a href=“http:www.baidu.com?userName=mike&amp;password=123”&gt; 百度 百度(在浏览器上显示的样子) # 5. 单域标签命令： 一组声明在 form 标签内部的标签命令 提示用户填写对应的【请求参数内容】，用于提供相对灵活的请求参数内容 所有的表单域标签都有两个属性【name，value】，name 属性声明【请求参数名】，value 属性声明【请求参数内容】 &lt;form aaction=“http://www.baidu.com”&gt; &lt;input type=“text” name=“userName” value=“mike”/&gt; &lt;input type=“submit” &lt;/form&gt; # 6. 表单域标签分类 &lt;input /&gt;（） &lt;select&gt;（） &lt;textarea&gt;（） # input 标签 &lt;input type=“submit”/&gt;（） 提交按钮也属于表单域标签，但是用于触发 form 命令，不作为请求参数使用 单选 &lt;input type=“radio” name=“sex” value=“man”/&gt; (男) &lt;input type=“radio” name=“sex” value=“woman”/&gt; (女) (name 相同表示划分为一组，就是这两个按钮只能选一个) 多选 擅长技术：&lt;input type=“checkbox” name=“技术” value=“java”/&gt; JAVA &lt;input type=“checkbox” name=“技术” value=“c++”/&gt; C++ 文件选择框 (要是用 get 会超过 4k 的) &lt;input type=“file” name=“myfile”/&gt;（用户头像:） 重置 &lt;input typr=“reset”/&gt; （） 属于表单域标签，但是用于将 form 中表单标签 value 设置初始值，不作为请求参数的内容（就是重置按钮） # select 标签 &lt;select name=“home”&gt; &lt;option value=“bj”&gt; 北京 &lt;option value=“sh”&gt; 上海 &lt;option value=“tj”&gt; 天津 &lt;/select&gt; （籍贯： 北京 上海 天津 ） 备注信息： &lt;textarea name=“tt” rows=10 cols=20&gt; （） (rows 是指展示 10 行信息，cols 是指每行可以写的个数) # 7. 表单域标签的默认值 大多数表单域标签 value 属性的默认值是空字符串 userName=’’ 对于 radio 与 checkbox 来说，value 属性默认值是’on’字符串 # 8. 表单域标签作为请求参数的条件 对于大多数表单域标签来说需要满足 必须声明在 form 标签的内部 必须声明 name 属性 对于 radio 标签与 checkbox 标签来说在满足上述两个条件的同时还必须被选中才可以作为请求参数（你不点按钮，当然不传参数） 如果表单域标签使用 disable 来修饰，失去作为请求参数的条件 readOnly 和 disabled 的区别 readOOnly: 可以作为请求参数 disabled: 永远不能作为请求参数 （用他们俩进行修饰后都无法更改属性）","link":"/2020/07/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%82%E6%95%B0/"},{"title":"控制浏览器发送请求地址","text":"# 超链接标签命令 &lt;a href=“请求地址”&gt; 提示信息 工作原理：超链接标签命令不会被浏览器自动执行 # 表单标签命令 &lt;form action=“请求地址”&gt; &lt;input type=“值”&gt;（取的值决定了 input 标签的功能和外观不同） &lt;/form&gt; # 请求方式 1.决定浏览器在发送请求时行为特征 2.浏览器的请求方式：7种【post】【get】 f12：打开浏览器控制台 3.get： （1）要求浏览器携带的请求参数数量不能超过4k （2）要求浏览器发送请求时，必须在浏览器地址栏上将请求参数信息展示出来 （3）要求必须将请求参数信息保存在HTTP请求协议包中【请求头】 （4）要求浏览器在接收到浏览器返回的资源文件内容后，必须将资源文件保存在浏览器的缓存当中 4.post： （1）可以携带任意数量的请求参数 （2）要求必须在浏览器的地址栏上隐藏请求参数信息 （3）要求必须将请求参数信息保存在http请求协议包中【请求体】 （4）禁止浏览器将服务器返回资源文件内容进行保存 5.控制浏览器采用get请求方式 （1）超链接标签命令执行时，要求浏览器必须采用get方式发送请求 （2）表单标签存在一个method属性，通过这个属性可以要求浏览器采用对应的请求方式发送请求 &lt;form action=&quot;请求地址&quot;method=&quot;get或者post&quot;&gt;（默认时get） 6.控制浏览器发送请求时采用post请求 只能用表单标签 7.请求方式使用场景 1.考虑到post请求方式，用户可以将病毒文件内容发送到服务器上进行攻击。 因此绝大多数门户级网站拒绝接受post请求，日常开发过程中绝大多数请求都是get 2.在某些特殊场景下必须使用post （1）文件上传 （2）发起登陆验证请求 （3）索要服务器中实时变化数据时（股票价格，车票数量。。。）","link":"/2020/08/03/%E6%8E%A7%E5%88%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80/"},{"title":"MySql子句顺序","text":"# 子句的输入顺序 SELECT FROM WHERE GROUP BY HAVING ORDER BY LIMIT # 子句的执行顺序 SELECT 语句中子句的执行顺序与 SELECT 语句中子句的输入顺序是不一样的 开始 -&gt;FROM 子句 -&gt;WHERE 子句 -&gt;GROUP BY 子句 -&gt;HAVING 子句 -&gt;ORDER BY 子句 -&gt;SELECT 子句 -&gt;LIMIT 子句 -&gt; 最终结果","link":"/2020/08/14/%E5%AD%90%E5%8F%A5%E9%A1%BA%E5%BA%8F/"},{"title":"异常","text":"# 一。异常 创建异常的目的：增强程序的健壮性。 异常在 java 中以类和对象的形式存在。 所有的异常都发生在运行阶段，异常出现时会自动 new 一个异常对象。 对于一些发生率较高的异常需要在运行之前对其进行预处理。 重写之后的方法不能比重写之前的方法抛出更多的异常，但是可以更少。 # 二。分类 编译时异常又被称为受检异常或者受控异常。CheckedException 运行时异常被称为非受检异常或者非受控异常。UnCheckedException 编译时异常一般发生的概率比较高。运行时异常一般发生的概率比较低。 继承关系： # Error 出现 error 程序直接终止，退出 jvm，而且它无法处理。 运行时异常在编写程序阶段可以选择处理也可以不处理。 Java 后台打印异常堆栈追踪信息的时候，采用了异常线程的方式打印的。 # Exception 编译时异常时表示必须在编写程序的时候预先对这种异常进行处理，不处理会报错。 # 三。异常处理的方式 第一种方式：在方法声明的位置使用 throws 关键字（抛给上一级） 第二种方式：使用 try catch 语句进行异常捕捉。 如过希望调用者处理，使用 throws，其他情况使用捕捉。 try{ 要检查的程序语句； } catch (异常类 对象名称){ 异常发生时的处理语句； } finally{ 一定会运行到的程序代码； } # throws Java 中异常发生之后如果一直上抛，最终抛给了 main 方法，main 方法继续向上抛，抛给了调用者 jvm，jvm 终止 Java 程序的执行。 可以抛出父类异常，throws 后面也可以写多个异常，需要用逗号隔开。 一般不建议在 main 方法上使用 throws，因为这个异常如果真正发生了，一定会抛给 jvm，jvm 只有终止。 一般 main 方法中的异常建议使用 try catch 进行捕捉。 # throw 和 throws 的区别 throw 表示生成异常对象并把它提交给运行时系统的过程。 throws 就是一个声明（在方法声明的位置上使用，表示上报异常信息给调用者），而 throw 是一个确切的动作。 # try…catch catch 的定义：运行时系统在方法的调用栈中查找，并从生成异常的方法开始进行回溯，直到找到包含相应异常处理的方法为止，这一过程称为异常的捕捉。 catch 的是 new 出来的异常对象的地址。 try 中出现异常，直接进入 catch 语句快中执行。try catch 把异常抓住之后，try catch 之后的代码继续执行，try 中的代码不会继续执行。 catch 后面的小括号中的类型可以写确切的类型，也可以是该类型的父类。 catch 可以写多个，建议 catch 的时候，精确的一个一个处理，这样有利于程序的调试。 catch 写多个的时候，从上到下必须遵守从小到大。 允许 catch 后面的小括号中采用 |（jdk8 的特性） # try…catch…finally 在 finally 子句中的代码是最后执行的，并且是一定会执行的，即使 try 语句快中的代码出现了异常。 finally 语句必须和 try 一起出现，不能单独编写。 通常在 finally 语句块中完成资源的释放 / 关闭。 try finally 可以联合使用。但是退出 jvm 之后，finally 语句中的代码就不执行了。 # 四。异常对象的方法 获取异常简单的描述信息： String msg = exception.getMessage(); 打印异常追踪的堆栈信息： exception.printStackTrace（）；（实际开发中建议使用这个）","link":"/2020/08/17/%E5%BC%82%E5%B8%B8/"}],"tags":[],"categories":[{"name":"java基础","slug":"java基础","link":"/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"网络通信","slug":"网络通信","link":"/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"MySql","slug":"MySql","link":"/categories/MySql/"}]}